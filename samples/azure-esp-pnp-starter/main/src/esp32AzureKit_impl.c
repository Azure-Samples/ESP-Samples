/*******************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.6.3.
 *
 * You need to add your implementation here to:
 *    - get telemetry data from device/sensor
 *    - set read-only property data
 *    - handle read-write property callback
 *    - process device command
 *
 * Generated Date: Thursday, November 7, 2019
 *******************************************************************************************/

#include "inc/esp32AzureKit_impl.h"
#include "inc/utilities/digitaltwin_serializer.h"
#include "inc/utilities/esp32azurekit_interface.h"
#include "inc/utilities/urn_azureiot_devicemanagement_deviceinformation_interface.h"
#include "inc/sensor.h"
#include "esp_log.h"
#include "esp_system.h"
#include "esp_spi_flash.h"

#define Payload_Buffer_Size 256
static const char *e_TAG = __FILE__ ;
static bool pitchNeedUpdate = true;
static bool rollNeedUpdate = true;
static bool pressureNeedUpdate = true;
static bool altitudeNeedUpdate = true;
static bool magnetXNeedUpdate = true;
static bool magnetYNeedUpdate = true;
static bool magnetZNeedUpdate = true;

static float temp, humidity, ambientLight;
static int pitch = 0, roll = 0;
static float pressure, altitude;
static int magnetX = 0, magnetY = 0, magnetZ = 0;

void Update_Sensor_Data()
{
    if (pitchNeedUpdate && rollNeedUpdate)
    {
        get_pitch_roll(&pitch, &roll);
        pitchNeedUpdate = false;
        rollNeedUpdate = false;
    }
    if (pressureNeedUpdate && altitudeNeedUpdate )
    {
        get_pressure_altitude(&pressure, &altitude);
        altitudeNeedUpdate = false;
        pressureNeedUpdate = false;
    }
    if (magnetXNeedUpdate && magnetYNeedUpdate && magnetZNeedUpdate)
    {
        get_magnetometer(&magnetX, &magnetY, &magnetZ);
        magnetXNeedUpdate = false;
        magnetYNeedUpdate = false;
        magnetZNeedUpdate = false;
    }
}

void SendTelemetry_Succeeded_Callback(const char* interfaceName, const char* telemetryName)
{
    // If needed, put your business logic here to handle the confirmation of the delivery for device telemetry on success.
    ESP_LOGD(e_TAG, "DigitalTwin successfully delivered telemetry message for %s::%s", interfaceName, telemetryName);
}

void SendTelemetry_Error_Callback(const char* interfaceName, const char* telemetryName)
{
    // If needed, put your business logic here to handle the confirmation of the delivery for device telemetry on failure.

    ESP_LOGD(e_TAG, "DigitalTwin failed to deliver telemetry message for %s::%s", interfaceName, telemetryName);
}

void ReportProperty_Succeeded_Callback(const char* interfaceName, const char* propertyName)
{
    // If needed, put your business logic here to handle the result callback reporting property on success.

    ESP_LOGD(e_TAG, "DigitalTwin successfully report writable property for %s::%s", interfaceName, propertyName);
}

void ReportProperty_Error_Callback(const char* interfaceName, const char* propertyName)
{
    // If needed, put your business logic here to handle the result callback of reporting property on failure.

    ESP_LOGD(e_TAG, "DigitalTwin failed to report writable property for %s::%s", interfaceName, propertyName);
}

long Esp32AzureKit_Telemetry_ReadPitch()
{
    Update_Sensor_Data();
    pitchNeedUpdate = true;
    ESP_LOGD(e_TAG, "Sending Telemetry: Pitch: %d", pitch);
    return pitch;
}

long Esp32AzureKit_Telemetry_ReadRoll()
{
    Update_Sensor_Data();
    rollNeedUpdate = true;
    ESP_LOGD(e_TAG, "Sending Telemetry: Roll: %d", roll);
    return roll;
}

double Esp32AzureKit_Telemetry_ReadPressure()
{
    Update_Sensor_Data();
    pressureNeedUpdate = true;
    ESP_LOGD(e_TAG, "Sending Telemetry: Pressure: %f", pressure);
    return pressure;
}

double Esp32AzureKit_Telemetry_ReadAltitude()
{
    Update_Sensor_Data();
    altitudeNeedUpdate = true;
    ESP_LOGD(e_TAG, "Sending Telemetry: Altitude: %f", altitude);
    return altitude;
}

long Esp32AzureKit_Telemetry_ReadMagnetX()
{
    Update_Sensor_Data();
    magnetXNeedUpdate = true;
    ESP_LOGD(e_TAG, "Sending Telemetry: Magnetometer-X: %d", magnetX);
    return magnetX;
}

long Esp32AzureKit_Telemetry_ReadMagnetY()
{
    Update_Sensor_Data();
    magnetYNeedUpdate = true;
    ESP_LOGD(e_TAG, "Sending Telemetry: Magnetometer-Y: %d", magnetY);
    return magnetY;
}

long Esp32AzureKit_Telemetry_ReadMagnetZ()
{
    Update_Sensor_Data();
    magnetZNeedUpdate = true;
    ESP_LOGD(e_TAG, "Sending Telemetry: Magnetometer-Z: %d", magnetZ);
    return magnetZ;
}

double Esp32AzureKit_Telemetry_ReadTemp()
{
    temp = get_temperature();
    ESP_LOGD(e_TAG, "Sending Telemetry: Temperature: %f", temp);
    return temp;
}

double Esp32AzureKit_Telemetry_ReadHumid()
{
    humidity = get_humidity();
    ESP_LOGD(e_TAG, "Sending Telemetry: Humidity: %f", humidity);
    return humidity;
}

double Esp32AzureKit_Telemetry_ReadLight()
{
    ambientLight = get_ambientLight();
    ESP_LOGD(e_TAG, "Sending Telemetry: Ambient Light: %f", ambientLight);
    return ambientLight;
}

long Esp32AzureKit_Telemetry_ReadMinFreeHeap()
{
    uint32_t minFreeHeap = esp_get_minimum_free_heap_size();
    return minFreeHeap;
}

bool Esp32AzureKit_Property_FanSpeedCallback(double fanSpeed)
{
    // TODO: provide implementation here
    ESP_LOGD(e_TAG, "FanSpeed property new value: %f", fanSpeed);
    return true;
}

bool Esp32AzureKit_Property_TempThresholdCallback(double tempThreshold)
{
    // TODO: provide implementation here
    ESP_LOGD(e_TAG, "TempThreshold property new value: %f", tempThreshold);
    return true;
}

DIGITALTWIN_COMMAND_RESULT Esp32AzureKit_Command_Echo(ESP32AZUREKIT_ECHO_echocommandrequest *echocommandrequest, char** response, unsigned int* statusCode)
{
    // TODO: provide implementation here
    // You need to process the device command, and set the command response and statusCode correspondingly.
    // Finally, return DIGITALTWIN_COMMAND_OK if the command execution succeeded, or 'DIGITALTWIN_COMMAND_ERROR' on failure.

    ESP_LOGD(e_TAG, "Parameter: echocommandrequest->displayedValue = %s", echocommandrequest->displayedValue);

    char* responseData = "Execute echo successfully";
    *response = (char*)calloc(strlen(responseData) + 1, sizeof(char));
    strncpy(*response, responseData, strlen(responseData));

    *statusCode = 200;
    ESP_LOGD(e_TAG, "Device executed 'echo' command successfully");
    return DIGITALTWIN_COMMAND_OK;
}

DIGITALTWIN_COMMAND_RESULT Esp32AzureKit_Command_StartFan(unsigned int* statusCode)
{
    // TODO: provide implementation here

    *statusCode = 200;
    ESP_LOGD(e_TAG, "Execute 'startFan' command successfully");
    return DIGITALTWIN_COMMAND_OK;
}

DIGITALTWIN_COMMAND_RESULT Esp32AzureKit_Command_StopFan(unsigned int* statusCode)
{
    // TODO: provide implementation here

    *statusCode = 200;
    ESP_LOGD(e_TAG, "Execute 'stopFan' command successfully");
    return DIGITALTWIN_COMMAND_OK;
}

char* Urn_azureiot_DeviceManagement_DeviceInformation_Property_GetManufacturer()
{
    return "Espressif Systems";
}

char* Urn_azureiot_DeviceManagement_DeviceInformation_Property_GetModel()
{
    esp_chip_info_t chip_info;
    esp_chip_info(&chip_info);
    // Todo : use chip_info.*
    return "ESP32-Azure IoT Kit";
}

char* Urn_azureiot_DeviceManagement_DeviceInformation_Property_GetSwVersion()
{
    return esp_get_idf_version() ;
}

char* Urn_azureiot_DeviceManagement_DeviceInformation_Property_GetOsName()
{
    return "freertos";
}

char* Urn_azureiot_DeviceManagement_DeviceInformation_Property_GetProcessorArchitecture()
{
    return "";
}

char* Urn_azureiot_DeviceManagement_DeviceInformation_Property_GetProcessorManufacturer()
{
    return "ESP32D0WDQ5";
}

long Urn_azureiot_DeviceManagement_DeviceInformation_Property_GetTotalStorage()
{
    return (spi_flash_get_chip_size()/1024) ; // to MB:  / (1024 * 1024));
}

long Urn_azureiot_DeviceManagement_DeviceInformation_Property_GetTotalMemory()
{
    uint32_t freeHeap = esp_get_free_heap_size();
    return freeHeap;
}

