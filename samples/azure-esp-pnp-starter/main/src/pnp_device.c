/*********************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.6.3.
 *
 * Generated Date: Thursday, November 7, 2019
 *********************************************************************************************/

#include "pnp_device.h"
#include "esp_log.h"
#include "esp_system.h"
#include <libgen.h>
#include "inc/utilities/digitaltwin_client_helper.h"

// Number of Digital Twins interfaces that this device supports.
#define DIGITALTWIN_INTERFACE_NUM 2

#define ESP32AZUREKIT_INDEX 0

#define URN_AZUREIOT_DEVICEMANAGEMENT_DEVICEINFORMATION_INDEX 1

#define DEFAULT_SEND_TELEMETRY_INTERVAL_MS 10000

#define DEVICE_CAPABILITY_MODEL_URI  CONFIG_DIGITALTWIN_DEVICE_CAPABILITY_MODEL_ID


static DIGITALTWIN_INTERFACE_CLIENT_HANDLE interfaceClientHandles[DIGITALTWIN_INTERFACE_NUM];
static TICK_COUNTER_HANDLE tickcounter = NULL ;

static tickcounter_ms_t lastTickSend;
static const char *TAG = "pnp_device"; 

int pnp_device_initialize(const char* connectionString, const char* trustedCert)
{
    ESP_LOGD(TAG, "pnp device initialize...");
    if ((tickcounter = tickcounter_create()) == NULL)
    {
        ESP_LOGE(TAG, "tickcounter_create failed");
        return -1;
    }

    DIGITALTWIN_DEVICE_CLIENT_LL_HANDLE digitalTwinDeviceClientHandle = NULL;
    memset(&interfaceClientHandles, 0, sizeof(interfaceClientHandles));

    // Initialize DigitalTwin device handle
    if ((digitalTwinDeviceClientHandle = DigitalTwinClientHelper_InitializeDeviceHandle(connectionString, false, trustedCert)) == NULL)
    {
        ESP_LOGE(TAG, "DigitalTwinClientHelper_InitializeDeviceHandle failed");
        return -1;
    }

    // Invoke to the ***Interface_Create - implemented in a separate library - to create DIGITALTWIN_INTERFACE_CLIENT_HANDLE.
    // NOTE: Other than creation and destruction, NO operations may occur on any DIGITALTWIN_INTERFACE_CLIENT_HANDLE
    // until after we've completed its registration (see DigitalTwinClientHelper_RegisterInterfacesAndWait).

    if ((interfaceClientHandles[ESP32AZUREKIT_INDEX] = Esp32AzureKitInterface_Create(digitalTwinDeviceClientHandle)) == NULL)
    {
        ESP_LOGE(TAG, "Esp32AzureKitInterface_Create failed");
        return -1;
    }

    if ((interfaceClientHandles[URN_AZUREIOT_DEVICEMANAGEMENT_DEVICEINFORMATION_INDEX] = Urn_azureiot_DeviceManagement_DeviceInformationInterface_Create(digitalTwinDeviceClientHandle)) == NULL)
    {
        ESP_LOGE(TAG, "Urn_azureiot_DeviceManagement_DeviceInformationInterface_Create failed");
        return -1;
    }

    // Register the interface(s) we've created with Azure IoT.  This call will block until interfaces
    // are successfully registered, we get a failure from server, or we timeout.
    if (DigitalTwinClientHelper_RegisterInterfacesAndWait(digitalTwinDeviceClientHandle, DEVICE_CAPABILITY_MODEL_URI, interfaceClientHandles, DIGITALTWIN_INTERFACE_NUM) != DIGITALTWIN_CLIENT_OK)
    {
        ESP_LOGE(TAG, "DigitalTwinClientHelper_RegisterInterfacesAndWait failed");
        return -1;
    }

    DigitalTwinClientHelper_Check();

    // report properties

    Urn_azureiot_DeviceManagement_DeviceInformationInterface_Property_ReportAll();

    tickcounter_get_current_ms(tickcounter, &lastTickSend);
    return 0;
}

void print_heap_summary(char* sEvent)
{
    uint32_t freeHeap = esp_get_free_heap_size();
    uint32_t minFreeHeap = esp_get_minimum_free_heap_size();
    ESP_LOGI(TAG, "Heap summary: %s", sEvent);
    ESP_LOGI(TAG, "-- Free heap = %d", freeHeap);
    ESP_LOGI(TAG, "-- Min free heap = %d", minFreeHeap);
}


void pnp_device_run()
{
    tickcounter_ms_t nowTick;
    tickcounter_get_current_ms(tickcounter, &nowTick);
    if (nowTick - lastTickSend >= DEFAULT_SEND_TELEMETRY_INTERVAL_MS)
    {
        print_heap_summary("");
        ESP_LOGI(TAG, "Send telemetry data to IoT Hub");
        Esp32AzureKitInterface_Telemetry_SendAll();
        tickcounter_get_current_ms(tickcounter, &lastTickSend);
    }
    else
    {
        // Just check data from IoT Hub
        DigitalTwinClientHelper_Check();
    }
}

void pnp_device_close()
{
    if (interfaceClientHandles[ESP32AZUREKIT_INDEX] != NULL)
    {
        Esp32AzureKitInterface_Close(interfaceClientHandles[ESP32AZUREKIT_INDEX]);
    }

    if (interfaceClientHandles[URN_AZUREIOT_DEVICEMANAGEMENT_DEVICEINFORMATION_INDEX] != NULL)
    {
        Urn_azureiot_DeviceManagement_DeviceInformationInterface_Close(interfaceClientHandles[URN_AZUREIOT_DEVICEMANAGEMENT_DEVICEINFORMATION_INDEX]);
    }

    if (tickcounter != NULL)
    {
        tickcounter_destroy(tickcounter);
    }

    DigitalTwinClientHelper_DeInitialize();
}
